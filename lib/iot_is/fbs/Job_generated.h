// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_JOB_JOBFLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_JOB_JOBFLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace JobFlatBuffers {

struct Job;
struct JobBuilder;
struct JobT;

struct Command;
struct CommandBuilder;
struct CommandT;

enum JobStatusEnum : int8_t {
  JobStatusEnum_JOB_QUEUED = 0,
  JobStatusEnum_JOB_IN_PROGRESS = 1,
  JobStatusEnum_JOB_PAUSED = 2,
  JobStatusEnum_JOB_SUCCEEDED = 3,
  JobStatusEnum_JOB_REJECTED = 4,
  JobStatusEnum_JOB_FAILED = 5,
  JobStatusEnum_JOB_TIMED_OUT = 6,
  JobStatusEnum_JOB_CANCELED = 7,
  JobStatusEnum_MIN = JobStatusEnum_JOB_QUEUED,
  JobStatusEnum_MAX = JobStatusEnum_JOB_CANCELED
};

inline const JobStatusEnum (&EnumValuesJobStatusEnum())[8] {
  static const JobStatusEnum values[] = {
    JobStatusEnum_JOB_QUEUED,
    JobStatusEnum_JOB_IN_PROGRESS,
    JobStatusEnum_JOB_PAUSED,
    JobStatusEnum_JOB_SUCCEEDED,
    JobStatusEnum_JOB_REJECTED,
    JobStatusEnum_JOB_FAILED,
    JobStatusEnum_JOB_TIMED_OUT,
    JobStatusEnum_JOB_CANCELED
  };
  return values;
}

inline const char * const *EnumNamesJobStatusEnum() {
  static const char * const names[9] = {
    "JOB_QUEUED",
    "JOB_IN_PROGRESS",
    "JOB_PAUSED",
    "JOB_SUCCEEDED",
    "JOB_REJECTED",
    "JOB_FAILED",
    "JOB_TIMED_OUT",
    "JOB_CANCELED",
    nullptr
  };
  return names;
}

inline const char *EnumNameJobStatusEnum(JobStatusEnum e) {
  if (::flatbuffers::IsOutRange(e, JobStatusEnum_JOB_QUEUED, JobStatusEnum_JOB_CANCELED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesJobStatusEnum()[index];
}

struct JobT : public ::flatbuffers::NativeTable {
  typedef Job TableType;
  std::string job_id{};
  std::vector<std::unique_ptr<JobFlatBuffers::CommandT>> commands{};
  JobFlatBuffers::JobStatusEnum status = JobFlatBuffers::JobStatusEnum_JOB_QUEUED;
  std::string name{};
  int32_t current_step = 0;
  int32_t total_steps = 0;
  int32_t current_cycle = 0;
  int32_t total_cycles = 0;
  bool paused = false;
  int64_t started_at = 0;
  int64_t finished_at = 0;
  JobT() = default;
  JobT(const JobT &o);
  JobT(JobT&&) FLATBUFFERS_NOEXCEPT = default;
  JobT &operator=(JobT o) FLATBUFFERS_NOEXCEPT;
};

struct Job FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JobT NativeTableType;
  typedef JobBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JOB_ID = 4,
    VT_COMMANDS = 6,
    VT_STATUS = 8,
    VT_NAME = 10,
    VT_CURRENT_STEP = 12,
    VT_TOTAL_STEPS = 14,
    VT_CURRENT_CYCLE = 16,
    VT_TOTAL_CYCLES = 18,
    VT_PAUSED = 20,
    VT_STARTED_AT = 22,
    VT_FINISHED_AT = 24
  };
  const ::flatbuffers::String *job_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_JOB_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<JobFlatBuffers::Command>> *commands() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<JobFlatBuffers::Command>> *>(VT_COMMANDS);
  }
  JobFlatBuffers::JobStatusEnum status() const {
    return static_cast<JobFlatBuffers::JobStatusEnum>(GetField<int8_t>(VT_STATUS, 0));
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t current_step() const {
    return GetField<int32_t>(VT_CURRENT_STEP, 0);
  }
  int32_t total_steps() const {
    return GetField<int32_t>(VT_TOTAL_STEPS, 0);
  }
  int32_t current_cycle() const {
    return GetField<int32_t>(VT_CURRENT_CYCLE, 0);
  }
  int32_t total_cycles() const {
    return GetField<int32_t>(VT_TOTAL_CYCLES, 0);
  }
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  int64_t started_at() const {
    return GetField<int64_t>(VT_STARTED_AT, 0);
  }
  int64_t finished_at() const {
    return GetField<int64_t>(VT_FINISHED_AT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_JOB_ID) &&
           verifier.VerifyString(job_id()) &&
           VerifyOffset(verifier, VT_COMMANDS) &&
           verifier.VerifyVector(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_CURRENT_STEP, 4) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_STEPS, 4) &&
           VerifyField<int32_t>(verifier, VT_CURRENT_CYCLE, 4) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_CYCLES, 4) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           VerifyField<int64_t>(verifier, VT_STARTED_AT, 8) &&
           VerifyField<int64_t>(verifier, VT_FINISHED_AT, 8) &&
           verifier.EndTable();
  }
  JobT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JobT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Job> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JobT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JobBuilder {
  typedef Job Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_job_id(::flatbuffers::Offset<::flatbuffers::String> job_id) {
    fbb_.AddOffset(Job::VT_JOB_ID, job_id);
  }
  void add_commands(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<JobFlatBuffers::Command>>> commands) {
    fbb_.AddOffset(Job::VT_COMMANDS, commands);
  }
  void add_status(JobFlatBuffers::JobStatusEnum status) {
    fbb_.AddElement<int8_t>(Job::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Job::VT_NAME, name);
  }
  void add_current_step(int32_t current_step) {
    fbb_.AddElement<int32_t>(Job::VT_CURRENT_STEP, current_step, 0);
  }
  void add_total_steps(int32_t total_steps) {
    fbb_.AddElement<int32_t>(Job::VT_TOTAL_STEPS, total_steps, 0);
  }
  void add_current_cycle(int32_t current_cycle) {
    fbb_.AddElement<int32_t>(Job::VT_CURRENT_CYCLE, current_cycle, 0);
  }
  void add_total_cycles(int32_t total_cycles) {
    fbb_.AddElement<int32_t>(Job::VT_TOTAL_CYCLES, total_cycles, 0);
  }
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(Job::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  void add_started_at(int64_t started_at) {
    fbb_.AddElement<int64_t>(Job::VT_STARTED_AT, started_at, 0);
  }
  void add_finished_at(int64_t finished_at) {
    fbb_.AddElement<int64_t>(Job::VT_FINISHED_AT, finished_at, 0);
  }
  explicit JobBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Job> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Job>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Job> CreateJob(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> job_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<JobFlatBuffers::Command>>> commands = 0,
    JobFlatBuffers::JobStatusEnum status = JobFlatBuffers::JobStatusEnum_JOB_QUEUED,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t current_step = 0,
    int32_t total_steps = 0,
    int32_t current_cycle = 0,
    int32_t total_cycles = 0,
    bool paused = false,
    int64_t started_at = 0,
    int64_t finished_at = 0) {
  JobBuilder builder_(_fbb);
  builder_.add_finished_at(finished_at);
  builder_.add_started_at(started_at);
  builder_.add_total_cycles(total_cycles);
  builder_.add_current_cycle(current_cycle);
  builder_.add_total_steps(total_steps);
  builder_.add_current_step(current_step);
  builder_.add_name(name);
  builder_.add_commands(commands);
  builder_.add_job_id(job_id);
  builder_.add_paused(paused);
  builder_.add_status(status);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Job> CreateJobDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *job_id = nullptr,
    const std::vector<::flatbuffers::Offset<JobFlatBuffers::Command>> *commands = nullptr,
    JobFlatBuffers::JobStatusEnum status = JobFlatBuffers::JobStatusEnum_JOB_QUEUED,
    const char *name = nullptr,
    int32_t current_step = 0,
    int32_t total_steps = 0,
    int32_t current_cycle = 0,
    int32_t total_cycles = 0,
    bool paused = false,
    int64_t started_at = 0,
    int64_t finished_at = 0) {
  auto job_id__ = job_id ? _fbb.CreateString(job_id) : 0;
  auto commands__ = commands ? _fbb.CreateVector<::flatbuffers::Offset<JobFlatBuffers::Command>>(*commands) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return JobFlatBuffers::CreateJob(
      _fbb,
      job_id__,
      commands__,
      status,
      name__,
      current_step,
      total_steps,
      current_cycle,
      total_cycles,
      paused,
      started_at,
      finished_at);
}

::flatbuffers::Offset<Job> CreateJob(::flatbuffers::FlatBufferBuilder &_fbb, const JobT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CommandT : public ::flatbuffers::NativeTable {
  typedef Command TableType;
  std::string name{};
  std::vector<double> params{};
};

struct Command FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandT NativeTableType;
  typedef CommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_PARAMS = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<double> *params() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_PARAMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.EndTable();
  }
  CommandT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CommandT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Command> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CommandBuilder {
  typedef Command Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Command::VT_NAME, name);
  }
  void add_params(::flatbuffers::Offset<::flatbuffers::Vector<double>> params) {
    fbb_.AddOffset(Command::VT_PARAMS, params);
  }
  explicit CommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Command> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Command>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Command> CreateCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> params = 0) {
  CommandBuilder builder_(_fbb);
  builder_.add_params(params);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Command> CreateCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<double> *params = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto params__ = params ? _fbb.CreateVector<double>(*params) : 0;
  return JobFlatBuffers::CreateCommand(
      _fbb,
      name__,
      params__);
}

::flatbuffers::Offset<Command> CreateCommand(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline JobT::JobT(const JobT &o)
      : job_id(o.job_id),
        status(o.status),
        name(o.name),
        current_step(o.current_step),
        total_steps(o.total_steps),
        current_cycle(o.current_cycle),
        total_cycles(o.total_cycles),
        paused(o.paused),
        started_at(o.started_at),
        finished_at(o.finished_at) {
  commands.reserve(o.commands.size());
  for (const auto &commands_ : o.commands) { commands.emplace_back((commands_) ? new JobFlatBuffers::CommandT(*commands_) : nullptr); }
}

inline JobT &JobT::operator=(JobT o) FLATBUFFERS_NOEXCEPT {
  std::swap(job_id, o.job_id);
  std::swap(commands, o.commands);
  std::swap(status, o.status);
  std::swap(name, o.name);
  std::swap(current_step, o.current_step);
  std::swap(total_steps, o.total_steps);
  std::swap(current_cycle, o.current_cycle);
  std::swap(total_cycles, o.total_cycles);
  std::swap(paused, o.paused);
  std::swap(started_at, o.started_at);
  std::swap(finished_at, o.finished_at);
  return *this;
}

inline JobT *Job::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<JobT>(new JobT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Job::UnPackTo(JobT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = job_id(); if (_e) _o->job_id = _e->str(); }
  { auto _e = commands(); if (_e) { _o->commands.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->commands[_i]) { _e->Get(_i)->UnPackTo(_o->commands[_i].get(), _resolver); } else { _o->commands[_i] = std::unique_ptr<JobFlatBuffers::CommandT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->commands.resize(0); } }
  { auto _e = status(); _o->status = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = current_step(); _o->current_step = _e; }
  { auto _e = total_steps(); _o->total_steps = _e; }
  { auto _e = current_cycle(); _o->current_cycle = _e; }
  { auto _e = total_cycles(); _o->total_cycles = _e; }
  { auto _e = paused(); _o->paused = _e; }
  { auto _e = started_at(); _o->started_at = _e; }
  { auto _e = finished_at(); _o->finished_at = _e; }
}

inline ::flatbuffers::Offset<Job> Job::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JobT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJob(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Job> CreateJob(::flatbuffers::FlatBufferBuilder &_fbb, const JobT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const JobT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _job_id = _o->job_id.empty() ? 0 : _fbb.CreateString(_o->job_id);
  auto _commands = _o->commands.size() ? _fbb.CreateVector<::flatbuffers::Offset<JobFlatBuffers::Command>> (_o->commands.size(), [](size_t i, _VectorArgs *__va) { return CreateCommand(*__va->__fbb, __va->__o->commands[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _status = _o->status;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _current_step = _o->current_step;
  auto _total_steps = _o->total_steps;
  auto _current_cycle = _o->current_cycle;
  auto _total_cycles = _o->total_cycles;
  auto _paused = _o->paused;
  auto _started_at = _o->started_at;
  auto _finished_at = _o->finished_at;
  return JobFlatBuffers::CreateJob(
      _fbb,
      _job_id,
      _commands,
      _status,
      _name,
      _current_step,
      _total_steps,
      _current_cycle,
      _total_cycles,
      _paused,
      _started_at,
      _finished_at);
}

inline CommandT *Command::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CommandT>(new CommandT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Command::UnPackTo(CommandT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = params(); if (_e) { _o->params.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->params[_i] = _e->Get(_i); } } else { _o->params.resize(0); } }
}

inline ::flatbuffers::Offset<Command> Command::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCommand(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Command> CreateCommand(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CommandT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _params = _o->params.size() ? _fbb.CreateVector(_o->params) : 0;
  return JobFlatBuffers::CreateCommand(
      _fbb,
      _name,
      _params);
}

inline const JobFlatBuffers::Job *GetJob(const void *buf) {
  return ::flatbuffers::GetRoot<JobFlatBuffers::Job>(buf);
}

inline const JobFlatBuffers::Job *GetSizePrefixedJob(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<JobFlatBuffers::Job>(buf);
}

inline bool VerifyJobBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<JobFlatBuffers::Job>(nullptr);
}

inline bool VerifySizePrefixedJobBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<JobFlatBuffers::Job>(nullptr);
}

inline void FinishJobBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<JobFlatBuffers::Job> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedJobBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<JobFlatBuffers::Job> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<JobFlatBuffers::JobT> UnPackJob(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<JobFlatBuffers::JobT>(GetJob(buf)->UnPack(res));
}

inline std::unique_ptr<JobFlatBuffers::JobT> UnPackSizePrefixedJob(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<JobFlatBuffers::JobT>(GetSizePrefixedJob(buf)->UnPack(res));
}

}  // namespace JobFlatBuffers

#endif  // FLATBUFFERS_GENERATED_JOB_JOBFLATBUFFERS_H_
